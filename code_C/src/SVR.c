#include "SVR.h"


int greaterThan(const void* a,const void* b){
    return *(unsigned int*)a > *(unsigned int*)b;
}

/*this function returns A where [A|id] is the parity check matrix 
  of the code generated by "codeWords". codeWords is altered and 
  put into systematic form, from that form a parity check matrix is derived.
  The parity check matrix is of the form cited above. appliedPermutation must be identity unless
  you know what you are doing. If appliedPermutation is identity then it will be altered to be the permutation
  applied to the code's coordinates for it to have the systematic form used to compute a parity check matrix
*/
Matrix make_parity_check_from_partial(Matrix partial,unsigned int n,unsigned int k){
    Matrix parityCheck= create_matrix(partial.matrix.nrows,n);
    unsigned int numBlocks=bitToBits(k);
    for(unsigned int i=0;i<parityCheck.matrix.nrows;++i){
        for(unsigned int j=0;j<numBlocks;++j){
            parityCheck.matrix.rows[i][j]=parityCheck.matrix.rows[i][j];
        }
    }
    for(unsigned int i=0;i<parityCheck.matrix.ncols;++i){
        matrix_write(parityCheck,i,i+partial.matrix.ncols,1);
    }
    return parityCheck;
}



int equal_on_positions(Vector v1,Vector v2,unsigned int* positions,unsigned int positionsCardinal){
    for(unsigned int k=0;k<positionsCardinal;++k){
        unsigned int pos=positions[k];
        if(get_coordinate(v1,pos)){
            if(!get_coordinate(v2,pos)){
                return 0;
            }
        }
        else{
            if(get_coordinate(v2,pos)){
                return 0;
            }
        }
    }
    return 1;
}

void generate_random_distinct_positions(unsigned int* postionsArray,const unsigned int d_s,const unsigned int maxPosition){
    int pickedZero=0;
    unsigned int count=0;
    for(unsigned int i=0;i<d_s;++i){
        postionsArray[i]=0;
    }
    while(count<d_s){
        unsigned int r=rand()%maxPosition;
        if(r==0 && !pickedZero){
            ++count;
            pickedZero=1;
        }
        else{
            if(not_in(postionsArray,d_s,r)){
                postionsArray[count]=r;
                ++count;
            }
        }
    }
}

void generate_random_binary_sequence(Bit* sequence,const unsigned int length){
    for(unsigned int i=0;i<length;++i){
        sequence[i]=rand()%2;
    }
}


int vector_matches_binary_sequence_on_positions(Vector v,Bit* sequence,unsigned int* positions,unsigned int sequenceLength){
    for(unsigned int k=0;k<sequenceLength;++k){
        if(get_coordinate(v,positions[k])!=sequence[k]){
            return 0;
        }
    }
    return 1;
}

List SVR(Matrix H_b,const unsigned int d_s,const unsigned int w_thres,const unsigned int N_iter){
    const unsigned int ns=H_b.matrix.ncols;
    const unsigned int ms=H_b.matrix.ncols-H_b.matrix.nrows;
    List foundVectors=create_List();
    unsigned int matchingPositions[d_s];
    Bit matchingVector[d_s];
    unsigned int selectedRowVectors[H_b.matrix.nrows];
    Vector sum=create_vector(H_b.matrix.ncols);
    unsigned int sumWeight;
    for(unsigned int iter=0;iter<N_iter;++iter){
        random_distinct_elements_in_range(d_s,0,ms,matchingPositions);
        for(unsigned int k=0;k<d_s;++k){
            matchingPositions[k]=H_b.sigma_col.permutation[matchingPositions[k]]; // allows to refer to the correct positions in the original matrix
        }
        generate_random_binary_sequence(matchingVector,d_s);
        unsigned int count=0;
        for(unsigned int k=0;k<H_b.matrix.nrows;++k){
            Vector row=matrix_get_row_copy(H_b,k);
            if(vector_matches_binary_sequence_on_positions(row,matchingVector,matchingPositions,d_s)){
                selectedRowVectors[count]=k;
                ++count;
            }
            destroy_vector(row);
        }
        for(unsigned int k=0;k<count;++k){
            for(unsigned int l=k+1;l<count;++l){
                Vector row1=rawmatrix_get_row_vector(H_b.matrix,selectedRowVectors[k]);
                Vector row2=rawmatrix_get_row_vector(H_b.matrix,selectedRowVectors[l]);
                vector_add(row1,row2,sum);
                sumWeight=HW(sum);
                if(sumWeight<=w_thres && sumWeight>0){// we found a sparse vector
                    Vector sparseVector=vector_copy(sum);
                    append_list(&foundVectors,sparseVector.bits);
                }
            }
        }

        unsigned int j=rand()%ms;
        unsigned int k=(rand()%H_b.matrix.nrows)+ms;
        matrix_swap_columns(H_b,j,k);
        left_block_row_reduce_matrix(H_b);
    }
    destroy_vector(sum);
    return foundVectors;
}


void do_nothing(void* element){

}


RawMatrix reconstruction_SVR(Bits** receivedWords,unsigned int numReceived,const unsigned int n,unsigned int k,const unsigned int ns,const unsigned int ms,const unsigned int d_s,const unsigned int w_thres,const unsigned int N_iter,const unsigned int circulantBlockSize,const unsigned int limSamplingIterations){
    
    int circulantWidth=circulantBlockSize;
    if(circulantBlockSize==0){
        circulantWidth=n;
    }
    unsigned int orbitSize=n/circulantWidth;
    if(n%circulantWidth!=0){
        orbitSize=1;
    }

    unsigned int rank=0;
    unsigned int dualDim=n-k;
    unsigned int iteration=0;
    unsigned int sampledIndices[ms];
    unsigned int sampledCoordinates[ns];
    RawMatrix out;
    out.ncols=n;
    out.nrows=0;
    out.rows=0;
    RawMatrix terec=rawmatrix_from_bits_array(receivedWords,numReceived,n);
    RawMatrix rec_copy=rawmatrix_copy(terec);

    Permutation inv=create_permutation(ns);

    Vector projPos=create_vector(n);

    while(rank<k && iteration<limSamplingIterations){
        ++iteration;
        RawMatrix recSample=create_empty_rows_matrix(ms);
        recSample.ncols=ns;

        random_distinct_elements_in_range(ms,0,numReceived,sampledIndices);
        random_distinct_elements_in_range(ns,0,n,sampledCoordinates);
        vector_set_positions_to_one(projPos,sampledCoordinates,ns,0);

        for(unsigned int i=0;i<ms;++i){
            Vector word=bits_to_vector(receivedWords[sampledIndices[i]],n);
            Vector row=projection(word,sampledCoordinates,ns);
            rawmatrix_replace_row(recSample,i,row);
        }
        

        Matrix matRec=rawmatrix_as_matrix(recSample);
        RawMatrix dual= dual_code_generator_matrix_with_permutation_no_copy(matRec.matrix,matRec.sigma_col);
        Matrix H_b=rawmatrix_as_matrix(dual);
        
        get_inverse_permutation(matRec.sigma_col,inv);
        List found=SVR(H_b,d_s,w_thres,N_iter);

        ListElement* element=found.firstElement;
        for(unsigned int i=0;i<found.listSize;++i){
            Vector SVRoutput=bits_to_vector(element->value,ns);
            Vector projectedVector=permuted_vector(inv,SVRoutput); // to undo coodinate permutation used to get systematic form matrix
            Vector extendedVector=extension(projectedVector,sampledCoordinates,n);// to undo coordinate sampling
            destroy_vector(SVRoutput);// we destroy the output of SVR
            element->value=extendedVector.bits;// and replace it with a likely parity check vector of the code's length
            destroy_vector(projectedVector);
            element=next_ListElement(element);
        }

        append_rows_to_rawmatrix(&out,found);

        List extraVectors =create_List();
        for(unsigned int i=0;i<out.nrows;++i){ // we use the structure of the code to get more parity check vectors
            Vector vec=rawmatrix_get_row_vector(out,i);
            for(unsigned int l=1;l<orbitSize;++l){
                Vector shifted=cyclic_right_shift_vector(vec,l*circulantWidth);
                vec=shifted;
                append_list(&extraVectors,vec.bits);
            }
        }

        append_rows_to_rawmatrix(&out,extraVectors);


        int newRank=row_echelonize_rawmatrix(out)+1;

        if(newRank>rank+(k/5)){
            rank=newRank;
            SparseVector parityVecs[rank];
            
            for(unsigned int i=0;i<rank;++i){
                parityVecs[i]=sparse_from_vector(rawmatrix_get_row_vector(out,i));
            }
            RawMatrix partialCorrectedWords=partial_corrected(terec,parityVecs,rank,10);
            destroy_rawmatrix(rec_copy);
            rec_copy=partialCorrectedWords;

            for(unsigned int i=0;i<rank;++i){
                destroy_sparse(&(parityVecs[i]));
            }
        }
        row_resize_rawmatrix(&out,newRank);
        destroy_matrix(H_b);
        
        destroy_List(&extraVectors,do_nothing);
        destroy_List(&found,do_nothing);
        destroy_permutation(matRec.sigma_col);
        free(recSample.rows);

        vector_set_to_zero(projPos);
    }
    destroy_rawmatrix(rec_copy);
    destroy_permutation(inv);
    destroy_rawmatrix(terec);
    destroy_vector(projPos);
    return out;
}

Vector single_SVR(RawMatrix H_b,const unsigned int d_s,const unsigned int w_thres,const unsigned int N_iter,int* found){
    unsigned int matchingPositions[d_s];
    Bit matchingVector[d_s];
    const unsigned int ms=H_b.ncols-H_b.nrows;

    unsigned int selectedRowVectors[H_b.nrows];
    Permutation sigmaCol=create_permutation(H_b.ncols);
    Vector sum=create_vector(H_b.ncols);
    unsigned int sumWeight=0;

#ifdef DEBUG
    if(ms<d_s){
        printf("ms < d_s!!!!\n");
        printf("ms=%u and d_s=%u\n",ms,d_s);
    }
#endif
    for(unsigned int iter=0;iter<N_iter;++iter){
        random_distinct_elements_in_range(d_s,0,ms,matchingPositions);
        for(unsigned int k=0;k<d_s;++k){
            matchingPositions[k]=sigmaCol.permutation[matchingPositions[k]]; // allows to refer to the correct positions in the original matrix
        }
        generate_random_binary_sequence(matchingVector,d_s);
        unsigned int count=0;
        for(unsigned int k=0;k<H_b.nrows;++k){
            Vector row=rawmatrix_get_row_vector(H_b,k);
            if(vector_matches_binary_sequence_on_positions(row,matchingVector,matchingPositions,d_s)){
                selectedRowVectors[count]=k;
                ++count;
            }
        }
        for(unsigned int k=0;k<count;++k){
            for(unsigned int l=k+1;l<count;++l){
                Vector row1=rawmatrix_get_row_vector(H_b,selectedRowVectors[k]);
                Vector row2=rawmatrix_get_row_vector(H_b,selectedRowVectors[l]);
                vector_add(row1,row2,sum);
                sumWeight=HW(sum);
                if(sumWeight<=w_thres && sumWeight>0){// we found a sparse vector
                    Vector sparseVector=vector_copy(sum);
                    destroy_vector(sum);
                    destroy_permutation(sigmaCol);
                    *found=1;
                    return sparseVector;
                }
            }
        }

        unsigned int j=rand()%ms;
        unsigned int k=(rand()%H_b.nrows)+ms;
        
        apply_transposition_to_permutation(sigmaCol,j,k);
        left_block_row_reduce_rawmatrix(H_b,sigmaCol);

    }
    destroy_vector(sum);
    destroy_permutation(sigmaCol);
    *found=0;
    return create_vector(H_b.ncols);
}



Vector find_sparse_vector_SVR(Bits** receivedWords,unsigned int numReceived,const unsigned int n,unsigned int k,const unsigned int ns,const unsigned int ms,const unsigned int d_s,const unsigned int w_thres,const unsigned int N_iter, unsigned int iterationLimit){

    RawMatrix workingMat;

    Permutation sigmaCol=create_permutation(ns);
    Permutation invSigmaCol=create_permutation(ns);


    workingMat.rows=calloc(ms,sizeof(Bits*));
    if(workingMat.rows==0){
        printf("could not allocate memory to store sampled rows and columns\n");
        return create_vector(n);
    }

    workingMat.ncols=ns;
    workingMat.nrows=ms;
    unsigned int sampledRows[ms];
    unsigned int sampledColumns[ns];
    Vector final;
    int found=0;

    for(unsigned int k=0;k<iterationLimit;++k){
        random_distinct_elements_in_range(ms,0,numReceived,sampledRows);
        random_distinct_elements_in_range(ns,0,n,sampledColumns);

        for(unsigned int l=0;l<ms;++l){
            Vector sampledWord=bits_to_vector(receivedWords[sampledRows[l]],n);
            workingMat.rows[l]=projection(sampledWord,sampledColumns,ns).bits;
        }
        RawMatrix H_b=dual_code_generator_matrix_with_permutation_no_copy(workingMat,sigmaCol);
        Vector foundVec=single_SVR(H_b,d_s,w_thres,N_iter,&found);
        if(found){
            k=iterationLimit;
            get_inverse_permutation(sigmaCol,invSigmaCol);
            permute_vector(invSigmaCol,&foundVec);
            final = extension(foundVec,sampledColumns,n);
            destroy_vector(foundVec);
        }
        else{
            destroy_vector(foundVec);
        }

        destroy_rawmatrix(H_b);
    }
    free(workingMat.rows);
    destroy_permutation(sigmaCol);
    destroy_permutation(invSigmaCol);
    if(found)
        return final;
    else
        return create_vector(n);
}

int argmax(unsigned int* array,unsigned int arraySize){
    unsigned int index=0;
    unsigned int max=0;
    for(unsigned int k=0;k<arraySize;++k){
        if(array[k]>max){
            index=k;
            max=array[k];
        }
    }
    return index;
}


void bit_flipping_iteration(Vector vector,SparseVector* sparseParityVectors,unsigned int numberParityVectors,int* satisfiesAllEquations){
    *satisfiesAllEquations=1;
    unsigned int numError[vector.size];//stores for each bit in vector the number of failed parity equations when the bit contributed to error
    for(unsigned int k=0;k<numberParityVectors;++k){
        Bit bit=scalar_product_sparse_and_vector(sparseParityVectors[k],vector);
        if(bit){//then all the bits that met a one in the parity vector will have contributed to one error
            *satisfiesAllEquations=0;
            for(unsigned int l=0;l<sparseParityVectors[k].numberOfOnes;++l){
                ++numError[sparseParityVectors[k].entries[l]];
            }
        }
    }
    if(!(*satisfiesAllEquations)){
        unsigned int index=argmax(numError,vector.size);

        Bit val=get_coordinate(vector,index);
        if(val){
            put_coordinate(vector,index,0);
        }
        else{
            put_coordinate(vector,index,1);
        }  
    }
}

void bit_flipping_correction(Vector vector,SparseVector* sparseParityVectors,unsigned int numberParityVectors,unsigned int maxIteration){
    int satisfiesEquations=0;
    for(unsigned int i=0;i<maxIteration;++i){
        bit_flipping_iteration(vector,sparseParityVectors,numberParityVectors,&satisfiesEquations);
        if(satisfiesEquations){
            break;
        }
    }
}

RawMatrix partial_corrected(RawMatrix receivedWords,SparseVector* sparseParityVectors,unsigned int numParityVecs,unsigned int maxIter){
    RawMatrix out=create_empty_rows_matrix(receivedWords.nrows);
    for(unsigned int k=0;k<receivedWords.nrows;++k){
        Vector copy=rawmatrix_get_row_copy(receivedWords,k);
        bit_flipping_correction(copy,sparseParityVectors,numParityVecs,maxIter);
        rawmatrix_replace_row(out,k,copy);
    }
    
    return out;
}
